import { createOpenAI } from '@ai-sdk/openai';
import { generateText, tool } from 'ai';
import { z } from 'zod';
import { FiltersObjectSchema, type SearchFilters } from './tools/searchFilters';

// --- Constants & Configuration ---
const TOGETHER_API_KEY = process.env.TOGETHER_API_KEY || '360f9aac434b4dfc684d0ff96bf193370dfc2b24d51c4107aadd2d061c26c5a0';
const TOGETHER_BASE_URL = process.env.TOGETHER_BASE_URL || "https://api.together.xyz/v1";
const MODEL_NAME = process.env.TOGETHER_MODEL_NAME || "meta-llama/Llama-4-Scout-17B-16E-Instruct";
const MODEL_TEMPERATURE = 0.01;

// --- Initialize Together AI Client ---
if (!TOGETHER_API_KEY) {
  console.warn(
    "TOGETHER_API_KEY environment variable not set. CVE Search Service may not function correctly."
  );
  // Consider throwing an error if the API key is absolutely critical for all operations
}
const together = createOpenAI({
  apiKey: TOGETHER_API_KEY,
  baseURL: TOGETHER_BASE_URL,
});

// --- Tool Definition for Vercel AI SDK ---
const cveFilterGenerationTool = tool({
  description: 'Generates a structured filter object based on a natural language query for CVE searching. Call this tool to translate user queries into searchable parameters.',
  parameters: FiltersObjectSchema, // LLM directly populates this schema
});

// --- System Prompt ---
function getSystemPrompt(): string {
  const todayDate = new Date();
  const year = todayDate.getFullYear();
  const month = (todayDate.getMonth() + 1).toString().padStart(2, '0');
  const day = todayDate.getDate().toString().padStart(2, '0');
  const formattedToday = `${year}-${month}-${day}`;

  return `
    TODAY is ${formattedToday}.
    You are an intelligent assistant helping users search for Common Vulnerabilities and Exposures (CVEs).
    Your primary goal is to translate the user's natural language query into a structured call to the 'cveFilterGenerationTool'.
    The 'cveFilterGenerationTool' has many available filter parameters, defined by FiltersObjectSchema. IMPORTANT: Most of these parameters are OPTIONAL.
    
    Follow these guidelines when populating the tool's arguments:
    1.  Focus on the user's core intent. Extract key entities like vendor names, product names, specific CVE IDs, or general keywords.
    2.  Only use a filter parameter if the user's query CLEARLY and EXPLICITLY indicates a constraint for that field.
    3.  If a potential filter is ambiguous or only weakly implied, DO NOT apply it. It's better to return more results than to incorrectly narrow the search.
    4.  Keywords: Use the 'keywords' field for general search terms.
    5.  Dates:
        - If a specific year is mentioned (e.g., "in 2023"), set published_from to YYYY-01-01 and published_to to YYYY-12-31 of that year.
        - For "recent" or time-relative queries (e.g., "last month," "past 90 days"), calculate the 'published_from' and 'published_to' dates relative to TODAY (${formattedToday}). Ensure YYYY-MM-DD format.
        - If no date range is specified, do not add date filters.
    6.  CVSS Scores/Vectors (cvss_min, cvss_max, attack_vector, etc.): Only populate these if the user provides very specific CVSS-related terms (e.g., "CVSS score above 7.5", "attack vector network"). Do not infer these from general terms like "critical" unless also accompanied by CVSS specifics.
    7.  CWE IDs: Only use the 'cwe_id' filter if the user explicitly mentions a CWE-ID (e.g., "CWE-79").
    8.  Unsupported Concepts: Do not attempt to infer or filter on concepts like "exploit available" or "used in ransomware" from keywords like "exploits" or "ransomware," as the search backend does not currently support direct filtering on these boolean flags. Focus on extracting explicit filterable criteria present in the schema.
    9.  Limit: A default limit is applied by the search. Do not set the 'limit' argument unless the user explicitly requests a different number of results.

    You MUST call 'cveFilterGenerationTool' with the arguments you've derived.
    If the query is too vague to extract any meaningful filters or keywords, or if it's not a CVE search request, do not call the tool. Instead, respond with a text message asking for clarification or explaining why you cannot proceed.
    Do not try to answer the query directly or generate SQL. Your sole responsibility is to accurately and judiciously populate and call 'cveFilterGenerationTool'.
  `.trim();
}

export interface CveServiceError {
  type: 'LLM_ERROR' | 'API_ERROR' | 'VALIDATION_ERROR';
  message: string;
  details?: any;
}

export interface CveServiceSuccess {
  rows: any[]; // Define a more specific CVERow type if available
  llmArgs?: SearchFilters;
}

/**
 * Takes a natural language query, gets structured search filters from an LLM,
 * and then executes the search by calling the /api/run_sql endpoint.
 * @param naturalQuery - The user's natural language query for CVEs.
 * @returns A promise that resolves to either the search results or an error object.
 */
export async function getAndExecuteCveSearch(
  naturalQuery: string
): Promise<CveServiceSuccess | CveServiceError> {
  if (!TOGETHER_API_KEY) {
    return { type: 'LLM_ERROR', message: "TOGETHER_API_KEY not configured." };
  }

  try {
    const result = await generateText({
      model: together(MODEL_NAME),
      tools: { cveFilterGenerationTool },
      messages: [
        { role: 'system', content: getSystemPrompt() },
        { role: 'user', content: naturalQuery },
      ],
      temperature: MODEL_TEMPERATURE,
    });

    const toolCall = result.toolCalls.find(tc => tc.toolName === 'cveFilterGenerationTool');

    if (!toolCall) {
      return { type: 'LLM_ERROR', message: result.text || 'LLM did not call the required tool.' };
    }
    
    // Validate the arguments from the LLM against our schema
    const validationResult = FiltersObjectSchema.safeParse(toolCall.args);
    if (!validationResult.success) {
      return {
        type: 'VALIDATION_ERROR',
        message: 'LLM tool arguments did not match schema.',
        details: validationResult.error.errors,
      };
    }
    const filters: SearchFilters = validationResult.data;

    // Call our backend API to execute the search with the validated filters
    const apiResponse = await fetch("/api/run_sql", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(filters), 
    });

    if (!apiResponse.ok) {
      const errorBody = await apiResponse.text();
      return { 
        type: 'API_ERROR', 
        message: `API request failed with status ${apiResponse.status}: ${errorBody}`,
        llmArgs: filters 
      };
    }

    const apiResult = await apiResponse.json();
    if (apiResult.error) {
      return { type: 'API_ERROR', message: `API returned an error: ${apiResult.error}`, llmArgs: filters };
    }

    return { rows: apiResult.rows || [], llmArgs: filters };

  } catch (error: any) {
    console.error("Error in getAndExecuteCveSearch:", error);
    return { type: 'LLM_ERROR', message: `Error during LLM or API interaction: ${error.message}` };
  }
}

/**
 * Example usage:
 * async function main() {
 *   const query = "show me critical RCE vulnerabilities in apache products from last 2 weeks";
 *   const result = await getAndExecuteCveSearch(query);
 *   if ('rows' in result) {
 *     console.log("CVEs found:", result.rows.length);
 *     console.table(result.rows.slice(0, 5));
 *     console.log("LLM arguments used:", result.llmArgs);
 *   } else {
 *     console.error(`Search failed [${result.type}]: ${result.message}`)
 *     if (result.details) console.error("Details:", result.details);
 *   }
 * }
 * // main(); // Ensure environment variables are set before running (TOGETHER_API_KEY, etc.)
 */ 