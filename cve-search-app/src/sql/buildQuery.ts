import { SearchFilters } from "../tools/searchFilters";

/**
 * Builds a parameterized SQL query from a SearchFilters object 
 * to search the 'rich_cve_entries' table.
 *
 * @param filters - The SearchFilters object.
 * @returns An object containing the SQL query string (\`text\`) and an array of arguments (\`args\`).
 */
export function buildSQL(filters: SearchFilters): { text: string; args: any[] } {
  const clauses: string[] = [];
  const args: any[] = [];

  const addClause = (expr: string, value?: any) => {
    if (value !== undefined && value !== null && value !== '') {
      args.push(value);
      clauses.push(expr.replace("?", `$${args.length}`));
    }
  };

  const addJsonContainsClause = (jsonColumn: string, jsonPath: string, value?: any) => {
    if (value !== undefined && value !== null && value !== '') {
      args.push(value);
      // Check if the JSON array contains an object with the specified path and value.
      // Example for problem_type_data: problem_type_data @> '[{\"description\":[{\"value\":\"CWE-XYZ\"}]}]''
      // This is a simplified example; for more complex JSON structures, a more specific path might be needed.
      // For CWE, we need to match problem_type_data->0->'description'->0->>'value' = $1
      clauses.push(`${jsonPath} = $${args.length}`);
    }
  };

  const addJsonFieldClause = (jsonColumn: string, jsonPathToArray: string, fieldInObject: string, value?:any) => {
    if (value !== undefined && value !== null && value !== '') {
        args.push(value);
        // Efficiently query JSONB: table.json_column @> '[{\"key\": \"value\"}]'::jsonb
        // This assumes the CWE is in problem_type_data[0].description[0].value
        // For a direct match: (problem_type_data->0->'description'->0->>'value') = $1
        clauses.push(`(${jsonColumn}${jsonPathToArray.replace(/[0]/g, "->0") /* convert array index to path */}${fieldInObject}) = $${args.length}`);
    }
  };

  const addJsonNumericFieldClause = (jsonColumn: string, jsonPath: string, operator: string, value?: number) => {
    if (value !== undefined && value !== null) {
      args.push(value);
      clauses.push(`(${jsonColumn}${jsonPath.replace(/[0]/g, "->0")})::numeric ${operator} $${args.length}`);
    }
  };

  // General keyword search (searches cve_id and description_text)
  if (filters.keywords) {
    const individualKeywords = filters.keywords.trim().split(/\s+/);
    if (individualKeywords.length > 0) {
      const keywordClauses = individualKeywords.map(word => {
        if (word) { // Ensure word is not empty after split
          args.push(`%${word}%`);
          const placeholder = `$${args.length}`;
          return `(cve_id ILIKE ${placeholder} OR description_text ILIKE ${placeholder})`;
        }
        return null;
      }).filter(clause => clause !== null);

      if (keywordClauses.length > 0) {
        clauses.push(`(${keywordClauses.join(" AND ")})`);
      }
    }
  }

  if (filters.cve_id) addClause("cve_id ILIKE ?", `%${filters.cve_id}%`);
  
  // For vendor and product, we'll assume a simple ILIKE on description_text for now
  // or if you add dedicated columns later, this can be updated.
  if (filters.vendor) addClause("description_text ILIKE ?", `%${filters.vendor}%`);
  if (filters.product) addClause("description_text ILIKE ?", `%${filters.product}%`);
  // Version filtering might be complex depending on how it's stored in configurations_data or description.
  // For now, also searching in description_text.
  if (filters.version) addClause("description_text ILIKE ?", `%${filters.version}%`);

  // Date filters
  if (filters.published_from) addClause("published_date >= ?", filters.published_from);
  if (filters.published_to)   addClause("published_date <= ?", filters.published_to);
  if (filters.updated_from)   addClause("last_modified_date >= ?", filters.updated_from);
  if (filters.updated_to)     addClause("last_modified_date <= ?", filters.updated_to);

  // CVSS Score and other metric filters from impact_data
  // Path based on your provided sample: impact_data->'baseMetricV3'->'cvssV3'->>'baseScore'
  const cvssBaseAccessPath = "->'baseMetricV3'->'cvssV3'->>";

  if (filters.cvss_min !== undefined) addJsonNumericFieldClause('impact_data', `${cvssBaseAccessPath}'baseScore'`, ">=", filters.cvss_min);
  if (filters.cvss_max !== undefined) addJsonNumericFieldClause('impact_data', `${cvssBaseAccessPath}'baseScore'`, "<=", filters.cvss_max);
  
  if (filters.attack_vector) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'attackVector'`, "", filters.attack_vector);
  if (filters.attack_complexity) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'attackComplexity'`, "", filters.attack_complexity);
  if (filters.privileges_required) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'privilegesRequired'`, "", filters.privileges_required);
  if (filters.user_interaction) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'userInteraction'`, "", filters.user_interaction);
  if (filters.scope) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'scope'`, "", filters.scope);
  if (filters.confidentiality_impact) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'confidentialityImpact'`, "", filters.confidentiality_impact);
  if (filters.integrity_impact) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'integrityImpact'`, "", filters.integrity_impact);
  if (filters.availability_impact) addJsonFieldClause('impact_data', `${cvssBaseAccessPath}'availabilityImpact'`, "", filters.availability_impact);

  // CWE ID filter
  // Path based on your sample: problem_type_data->0->'description'->0->>'value'
  if (filters.cwe_id) {
     // To check if the value exists in the specific path:
     addClause(`(problem_type_data->0->'description'->0->>'value') = ?`, filters.cwe_id);
     // If CWE could be in any part of the problem_type_data description arrays, a more complex query would be needed, e.g. using JSONB functions or @> operator with a specific structure.
  }
  
  // Boolean flags (assuming these columns exist or will be added)
  // if (filters.has_exploit !== undefined) addClause("has_exploit = ?", filters.has_exploit);
  // if (filters.ransomware !== undefined) addClause("ransomware = ?", filters.ransomware);

  const whereClause = clauses.length ? `WHERE ${clauses.join(" AND ")}` : "";
  
  // Columns must match the order and names in the RETURNS TABLE definition of exec_readonly SQL function
  const selectedColumns = [
    "cve_id",
    "description_text",
    "published_date",
    "last_modified_date",
    "assigner",
    "impact_data",
    "references_data",
    "problem_type_data"
    // "id" column was removed as it's not in the SQL function's return type.
    // Ensure other data like problem_type_data, references_data, impact_data are what you need.
  ].join(", ");

  const text = `
    SELECT
        ${selectedColumns}
    FROM
        rich_cve_entries
    ${whereClause}
    ORDER BY
        published_date DESC
    LIMIT $${args.length + 1};
  `;
  args.push(filters.limit || 50);

  return { text, args };
} 