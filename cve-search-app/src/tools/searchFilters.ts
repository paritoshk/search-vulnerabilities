import { z } from "zod";

/**
 * Defines the actual filter fields that the LLM should generate.
 * This schema is used by the Vercel AI SDK tool for its parameters
 * and by the /api/run_sql endpoint for validating the request body.
 */
export const FiltersObjectSchema = z.object({
  keywords: z.string().optional().describe("Keywords to search in description or other text fields. Include general vendor, product, or version terms here."),
  // vendor:          z.string().optional().describe("e.g., 'Microsoft', 'Apache'"),
  // product:         z.string().optional().describe("e.g., 'Windows 10', 'Struts'"),
  // version:         z.string().optional().describe("Specific version of the product"),
  cve_id:          z.string().optional().describe("Specific CVE ID, e.g., 'CVE-2021-44228'"),
  cwe_id:          z.string().optional().describe("Common Weakness Enumeration ID, e.g., 'CWE-89' for SQL Injection"),
  cvss_min:        z.number().min(0).max(10).optional().describe("Minimum CVSS base score (0.0-10.0)"),
  cvss_max:        z.number().min(0).max(10).optional().describe("Maximum CVSS base score (0.0-10.0)"),
  // has_exploit:     z.boolean().optional().describe("Filter by presence of a known public exploit (requires a corresponding 'has_exploit' boolean column in the database)"),
  // ransomware:      z.boolean().optional().describe("Filter if associated with ransomware campaigns (requires a corresponding 'ransomware' boolean column in the database)"),
  published_from:  z.coerce.date().optional().describe("CVE published from this date. LLM should convert to YYYY-MM-DD format."),
  published_to:    z.coerce.date().optional().describe("CVE published up to this date. LLM should convert to YYYY-MM-DD format."),
  updated_from:    z.coerce.date().optional().describe("CVE last updated from this date. LLM should convert to YYYY-MM-DD format."),
  updated_to:      z.coerce.date().optional().describe("CVE last updated up to this date. LLM should convert to YYYY-MM-DD format."),
  categories:      z.array(
                     z.enum([
                       "overflow","memory_corruption","sql_injection","xss",
                       "directory_traversal","file_inclusion","csrf",
                       "xxe","ssrf","open_redirect","code_exec",
                       "bypass","priv_escalation","dos","info_leak"
                     ])
                   ).optional().describe("Broad categories of vulnerabilities. This might require mapping to CWEs or tags."),
  attack_vector:   z.enum(["PHYSICAL","LOCAL","ADJACENT_NETWORK","NETWORK"]).optional().describe("CVSS attack vector (e.g., NETWORK)"),
  attack_complexity:z.enum(["LOW","HIGH"]).optional().describe("CVSS attack complexity"),
  scope:           z.enum(["UNCHANGED","CHANGED"]).optional().describe("CVSS scope"),
  user_interaction:z.enum(["NONE","REQUIRED"]).optional().describe("CVSS user interaction"),
  privileges_required:z.enum(["NONE","LOW","HIGH"]).optional().describe("CVSS privileges required"),
  confidentiality_impact: z.enum(["NONE","LOW","HIGH"]).optional().describe("CVSS confidentiality impact"),
  integrity_impact:       z.enum(["NONE","LOW","HIGH"]).optional().describe("CVSS integrity impact"),
  availability_impact:    z.enum(["NONE","LOW","HIGH"]).optional().describe("CVSS availability impact"),
  limit:           z.number().int().positive().max(200).default(50).describe("Number of results to return, default 50, max 200.")
});

// Type for the actual, parsed filter fields.
export type SearchFilters = z.infer<typeof FiltersObjectSchema>; 