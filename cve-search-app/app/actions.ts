'use server';

import { createOpenAI } from '@ai-sdk/openai';
import { generateText, tool, type Tool, type ToolInvocation, type GenerateTextResult } from 'ai'; // Ensure ToolResultPart is removed if not used, Add GenerateTextResult
import { getSupabaseServerClient } from '@/utils/supabase/server';
import { z } from 'zod';
import { createAI } from 'ai/rsc';

// --- Constants & Configuration ---
const TOGETHER_API_KEY = process.env.TOGETHER_API_KEY;
const TOGETHER_BASE_URL = "https://api.together.xyz/v1";
const MODEL_NAME = "meta-llama/Llama-4-Scout-17B-16E-Instruct"; // Reverted to Qwen model
const MODEL_TEMPERATURE = 0.01;

// --- Zod Schema for the Search Tool's Input Parameters ---
const CveSearchToolInputSchema = z.object({
  keywords: z.array(z.string()).optional().describe("Keywords to search for in CVE descriptions or IDs. E.g., ['Apache Log4j', 'RCE']."),
  severities: z.array(z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"])).optional().describe("Array of CVE severities to filter by. E.g., ['CRITICAL', 'HIGH']."),
  cwe_ids: z.array(z.string()).optional().describe("Array of Common Weakness Enumeration (CWE) IDs. E.g., ['CWE-79', 'CWE-89']."),
  assigner: z.string().optional().describe("The CNA (CVE Numbering Authority) assigner. E.g., 'psirt@adobe.com'."),
  published_start_date: z.string().optional().describe("Start date for CVE publication (YYYY-MM-DD). E.g., '2023-01-01'."),
  published_end_date: z.string().optional().describe("End date for CVE publication (YYYY-MM-DD). E.g., '2023-12-31'."),
  vulnerability_id: z.string().optional().describe("A specific CVE ID. E.g., 'CVE-2023-12345'.")
}).describe("Parameters for searching CVEs.");

// --- Tool Definition for Vercel AI SDK ---
// The name of the tool will be the key in the tools object passed to generateText.
const cveSearchToolDefinition = tool({
  description: 'Searches for CVEs based on specified criteria. Call this tool to find vulnerabilities matching user queries.',
  parameters: CveSearchToolInputSchema,
  // We are not using the SDK's execute functionality directly here, as we process toolInvocations manually.
  // If an execute function were strictly required by the `tool` helper or types, it could be a simple pass-through or logger.
  // execute: async (args) => args, 
});

// --- Initialize Together AI Client ---
if (!TOGETHER_API_KEY) {
  console.warn("TOGETHER_API_KEY environment variable not set. Search will not work.");
}
const together = createOpenAI({
  apiKey: TOGETHER_API_KEY, 
  baseURL: TOGETHER_BASE_URL,
});

// Type for the tools object passed to generateText
// It maps tool names (strings) to Tool definitions.
// The generic type for Tool should be its parameters schema.
interface AppTools {
  [key: string]: Tool<z.ZodTypeAny, any>; // Index signature for ToolSet compatibility
  searchCVEsTool: Tool<typeof CveSearchToolInputSchema, any>; // Specify RESULT type as any
}

// --- Function to get structured search arguments from LLM using the tool ---
async function getToolArgumentsForCVESearch(naturalQuery: string): Promise<{
  arguments?: z.infer<typeof CveSearchToolInputSchema>;
  errorMessage?: string;
  rawLLMResponse?: any; 
}> {
  if (!TOGETHER_API_KEY) {
    return { errorMessage: "TOGETHER_API_KEY not configured." };
  }

  const todayDate = new Date();
  const year = todayDate.getFullYear();
  const month = (todayDate.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
  const day = todayDate.getDate().toString().padStart(2, '0');
  const formattedToday = `${year}-${month}-${day}`;

  const systemPrompt = `
    TODAY is ${formattedToday}.
    You are an intelligent assistant that helps users search for Common Vulnerabilities and Exposures (CVEs).
    Your task is to understand the user's natural language query and translate it into a call to the 'searchCVEsTool'.
    You MUST call the 'searchCVEsTool' to fulfill the user's request by providing its arguments.
    Populate the arguments for the tool based on the user's query.
    - For date ranges, if a single year is mentioned (e.g., "in 2023"), set published_start_date to YYYY-01-01 and published_end_date to YYYY-12-31.
    - If the user asks for "recent" vulnerabilities, you are responsible for calculating the date range. Set published_start_date to 30 days ago from today (which is ${formattedToday}) and published_end_date to today (which is ${formattedToday}). Format both as YYYY-MM-DD.
    - If the query is too vague or you cannot determine appropriate parameters for the tool, do not call the tool. Instead, respond with a text message explaining what information is missing.
    - Do not try to answer the query directly or generate SQL. Your only job is to call 'searchCVEsTool' correctly or explain why you cannot.
  `;

  try {
    const toolsObject: AppTools = { searchCVEsTool: cveSearchToolDefinition };

    // Use typeof toolsObject for the TOOLS generic argument, and string for OUTPUT
    const result: GenerateTextResult<typeof toolsObject, string> = await generateText({
      model: together(MODEL_NAME),
      tools: toolsObject,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: naturalQuery },
      ],
      temperature: MODEL_TEMPERATURE,
    });

    console.log("DEBUG: Raw LLM result object:", JSON.stringify(result, null, 2));

    const toolCalls = result.toolCalls;
    const text = result.text;

    console.log("DEBUG: Extracted toolCalls:", JSON.stringify(toolCalls, null, 2));
    console.log("DEBUG: Extracted text:", text);

    if (toolCalls && Array.isArray(toolCalls) && toolCalls.length > 0) {
      const toolCall = toolCalls.find(ti => ti.toolName === 'searchCVEsTool'); 
      if (toolCall) {
        console.log("DEBUG: Found toolCall for searchCVEsTool:", JSON.stringify(toolCall.args, null, 2));
        const validationResult = CveSearchToolInputSchema.safeParse(toolCall.args);
        if (validationResult.success) {
          const args = validationResult.data;
          // If "recent" or "new" is in the query, always override/set the dates to the last 30 days.
          const lowerCaseQuery = naturalQuery.toLowerCase();
          if (
            lowerCaseQuery.includes("recent") ||
            lowerCaseQuery.includes("new")
          ) {
            const today = new Date(); // Use current date for calculation
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);
            args.published_start_date = thirtyDaysAgo.toISOString().split('T')[0];
            args.published_end_date = today.toISOString().split('T')[0];
            console.log(`DEBUG: Overriding dates for 'recent'/'new' query. Start: ${args.published_start_date}, End: ${args.published_end_date}`);
          }
          args.keywords = args.keywords || [];
          args.severities = args.severities || [];
          args.cwe_ids = args.cwe_ids || [];
          return { arguments: args, rawLLMResponse: toolCall.args };
        } else {
          console.error("Tool arguments failed Zod validation:", validationResult.error.errors);
          return { errorMessage: `LLM tool arguments did not match schema: ${validationResult.error.errors.map(e => e.message).join(', ')}`, rawLLMResponse: toolCall.args };
        }
      } else {
         console.log("DEBUG: searchCVEsTool not found in toolCalls.");
         return { errorMessage: "LLM called an unexpected tool or did not provide arguments for searchCVEsTool.", rawLLMResponse: toolCalls };
      }
    }
    console.log("DEBUG: No toolCalls or empty array.");
    return { errorMessage: text || "LLM did not call the required tool and provided no text explanation.", rawLLMResponse: text };

  } catch (error: any) {
    console.error("Error in getToolArgumentsForCVESearch:", error);
    let errorMessageText = error.message;
    if (error.cause && error.cause.message) { errorMessageText += ` (Cause: ${error.cause.message})`; }
    return { errorMessage: `Error interacting with LLM: ${errorMessageText}` };
  }
}

// --- Function to build SQL WHERE conditions from tool arguments ---
function buildSqlConditionsFromToolArguments(args: z.infer<typeof CveSearchToolInputSchema>): string[] {
  const conditions: string[] = [];
  const escapeSql = (val: string) => val.replace(/'/g, "''"); // Helper to escape single quotes

  if (args.vulnerability_id) {
    conditions.push(`cve_id ILIKE '${escapeSql(args.vulnerability_id)}%'`);
  }
  if (args.keywords && args.keywords.length > 0) {
    args.keywords.forEach(keyword => {
      conditions.push(`(description_text ILIKE '%${escapeSql(keyword)}%' OR cve_id ILIKE '%${escapeSql(keyword)}%')`);
    });
  }
  if (args.severities && args.severities.length > 0) {
    const severityConditions = args.severities.map(s => `impact_data->'baseMetricV3'->'cvssV3'->>'baseSeverity' = '${escapeSql(s)}'`);
    if (severityConditions.length > 0) conditions.push(`(${severityConditions.join(' OR ')})`);
  }
  if (args.cwe_ids && args.cwe_ids.length > 0) {
    const cweConditions = args.cwe_ids.map(cwe => 
      `problem_type_data @> '[{"description":[{"value":"${escapeSql(cwe)}"}]}]'::jsonb`
    );
    if (cweConditions.length > 0) conditions.push(`(${cweConditions.join(' OR ')})`);
  }
  if (args.assigner) {
    conditions.push(`assigner ILIKE '%${escapeSql(args.assigner)}%'`);
  }
  if (args.published_start_date) {
    conditions.push(`published_date >= '${escapeSql(args.published_start_date)}'`);
  }
  if (args.published_end_date) {
    conditions.push(`published_date <= '${escapeSql(args.published_end_date)} 23:59:59'`);
  }
  return conditions;
}

// --- Server Action to Fetch CVEs (Updated) ---
export interface CVE { 
  cve_id: string;
  description_text: string | null;
  published_date: string | null;
  last_modified_date: string | null;
  assigner: string | null;
  impact_data: any | null; 
  references_data: any | null;
  problem_type_data: any | null;
}
export interface SearchResult { 
  cves: CVE[];
  llmQueryAnalysis?: {
    toolArguments?: z.infer<typeof CveSearchToolInputSchema>; 
    generatedSqlConditions?: string[];
    errorMessage?: string;
    rawResponse?: any; 
  };
  dbError?: string;
}

export async function searchCVEsAction(naturalQuery: string): Promise<SearchResult> {
  'use server';
  if (!naturalQuery || naturalQuery.trim() === '') {
    return { cves: [] };
  }

  const toolCallResult = await getToolArgumentsForCVESearch(naturalQuery);

  if (toolCallResult.errorMessage || !toolCallResult.arguments) {
    return {
      cves: [],
      llmQueryAnalysis: {
        errorMessage: toolCallResult.errorMessage || "LLM failed to provide valid tool arguments.",
        rawResponse: toolCallResult.rawLLMResponse,
        toolArguments: toolCallResult.arguments, 
        generatedSqlConditions: [] 
      }
    };
  }

  const sqlConditions = buildSqlConditionsFromToolArguments(toolCallResult.arguments);

  if (sqlConditions.length === 0 && !toolCallResult.errorMessage) {
    // This case can happen if LLM calls tool with empty args not matching any specific filterable field.
    return {
      cves: [],
      llmQueryAnalysis: {
        toolArguments: toolCallResult.arguments,
        generatedSqlConditions: [],
        errorMessage: "The AI understood your query but it didn't map to specific search filters. Try a more specific query.",
        rawResponse: toolCallResult.rawLLMResponse
      }
    };
  }
  
  const supabase = await getSupabaseServerClient();
  let queryBase = 'SELECT cve_id, description_text, published_date, last_modified_date, assigner, impact_data, references_data, problem_type_data FROM rich_cve_entries';
  const whereConditions = sqlConditions.join(' AND ');

  if (whereConditions) {
    queryBase += ` WHERE ${whereConditions}`;
  }
  queryBase += ' ORDER BY published_date DESC NULLS LAST LIMIT 50';

  console.log("Executing SQL from tool args:", queryBase);

  try {
    const { data, error } = await supabase.rpc('execute_sql', { sql_query: queryBase }) as { data: CVE[] | null, error: any };

    if (error) {
      console.error("Supabase query error:", error);
      return { cves: [], dbError: error.message, llmQueryAnalysis: { toolArguments: toolCallResult.arguments, generatedSqlConditions: sqlConditions, rawResponse: toolCallResult.rawLLMResponse } };
    }
    return { cves: data || [], llmQueryAnalysis: { toolArguments: toolCallResult.arguments, generatedSqlConditions: sqlConditions, rawResponse: toolCallResult.rawLLMResponse } };
  } catch (e: any) {
    console.error("Database execution error:", e);
    return { cves: [], dbError: e.message, llmQueryAnalysis: { toolArguments: toolCallResult.arguments, generatedSqlConditions: sqlConditions, rawResponse: toolCallResult.rawLLMResponse } };
  }
}

export const AI = createAI<{
  cveResults?: CVE[];
  llmAnalysis?: SearchResult['llmQueryAnalysis'] 
  dbError?: string;
}, {
  searchResults?: SearchResult;
}> ({
  actions: {
    searchCVEsAction,
  },
  initialAIState: {},
  initialUIState: { searchResults: { cves: []} },
}); 