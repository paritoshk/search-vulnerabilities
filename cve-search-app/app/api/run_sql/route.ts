import { type NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { FiltersObjectSchema, type SearchFilters } from "../../../src/tools/searchFilters"; 
import { buildSQL } from "../../../src/sql/buildQuery";

// Initialize Supabase client
// Ensure SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in your .env file
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceRoleKey) {
  // Log the error on the server, but don't expose details to the client
  console.error("Supabase URL or Service Role Key is not defined.");
  // For a production app, you might have a more robust error handling or startup check
  // For now, this will cause an error response if the API is hit without these vars.
}
// Initialize Supabase client only if keys are present.
// The request handler will check if supabase is initialized.
const supabase = (supabaseUrl && supabaseServiceRoleKey) 
  ? createClient(supabaseUrl, supabaseServiceRoleKey)
  : null;

/**
 * API handler for executing read-only SQL queries for CVE search.
 * Expects a POST request with a body matching FiltersObjectSchema.
 * This is an App Router route handler.
 */
export async function POST(req: NextRequest) {
  if (!supabase) {
    console.error("Supabase client is not initialized due to missing environment variables.");
    return NextResponse.json({ error: "Server configuration error." }, { status: 500 });
  }

  let filters: SearchFilters;
  try {
    const requestBody = await req.json();
    filters = FiltersObjectSchema.parse(requestBody);
  } catch (error: any) {
    console.error("Error parsing request body:", error);
    if (error.name === 'ZodError') {
      return NextResponse.json({ error: "Invalid request body.", details: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: "Invalid JSON in request body." }, { status: 400 });
  }

  try {
    const { text, args } = buildSQL(filters); 

    const { data, error: rpcError } = await supabase.rpc("exec_readonly", {
      params: args,
      q: text,
    });

    if (rpcError) {
      console.error("Supabase RPC error:", rpcError);
      let statusCode = 500;
      // PGRST200 (OK) and PGRST116 (Not Found) might be treated differently by Supabase rpc for empty results vs actual errors
      // For simplicity, treating all rpcErrors as server-side or DB issues.
      // You might want to refine status codes based on specific rpcError.code values
      if (rpcError.code && (rpcError.code.startsWith('PGRST') || rpcError.code.startsWith('22P02') /* invalid input syntax for type json */ ) ) {
        statusCode = 400; // Bad request if query params lead to SQL error or no data
      }
      return NextResponse.json({ error: `Database error: ${rpcError.message}` }, { status: statusCode });
    }

    return NextResponse.json({ rows: data });
  } catch (error: any) {
    console.error("Error in /api/run_sql (POST):", error);
    // This catches errors in buildSQL or unexpected issues
    return NextResponse.json({ error: `Server error: ${error.message}` }, { status: 500 });
  }
}

// Optional: Add a GET handler for health check or to prevent 405 on GET requests
export async function GET() {
  return NextResponse.json({ message: "API route is active. Use POST to submit queries." });
} 